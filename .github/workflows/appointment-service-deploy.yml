name: Appointment Service - Deploy to AKS
on:
  workflow_run:
    workflows: ["Appointment Service CI/CD Pipeline"]
    types:
      - completed
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      image_tag:
        description: 'Image tag to deploy (optional - uses latest if empty)'
        required: false
        type: string
 
env:
  REGISTRY_LOGIN_SERVER: appointmentservice.azurecr.io
  IMAGE_NAME: appointment-service
  AKS_CLUSTER_NAME: aks-dev-cluster-dev-s985
  AKS_RESOURCE_GROUP: rg-aks-dev
  NAMESPACE: healthcare-services
 
jobs:
  deploy-staging:
    name: Deploy to AKS Staging
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment: staging
   
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
 
    - name: Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      env:
        AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
 
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
 
    - name: Get AKS Credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
          --name ${{ env.AKS_CLUSTER_NAME }} \
          --overwrite-existing
 
    - name: Create Namespace if not exists
      run: |
        kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
 
    - name: Create ACR Secret
      run: |
        kubectl create secret docker-registry acr-secret \
          --namespace=${{ env.NAMESPACE }} \
          --docker-server=${{ env.REGISTRY_LOGIN_SERVER }} \
          --docker-username=appointmentservice \
          --docker-password=${{ secrets.APPOINTMENT_ACR_PASSWORD }} \
          --dry-run=client -o yaml | kubectl apply -f -
 
    - name: Determine Image Tag
      id: image-tag
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ -n "${{ github.event.inputs.image_tag }}" ]; then
          echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
        else
          echo "tag=main-${{ github.sha }}" >> $GITHUB_OUTPUT
        fi
 
    - name: Update Image in Deployment Manifest
      run: |
        IMAGE_TAG="${{ steps.image-tag.outputs.tag }}"
        IMAGE_FULL="${{ env.REGISTRY_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}"
       
        echo "Updating deployment manifest with image: $IMAGE_FULL"
       
        # Update the image in the deployment manifest
        sed -i "s|image:.*|image: $IMAGE_FULL|g" AKS-Deployment/appointment-deployment-dev.yml
       
        # Display the updated manifest for verification
        echo "Updated deployment manifest:"
        cat AKS-Deployment/appointment-deployment-dev.yml
 
    - name: Deploy to AKS Staging
      run: |
        echo "Deploying to AKS using existing manifests..."
       
        # Apply the deployment manifest
        kubectl apply -f AKS-Deployment/appointment-deployment-dev.yml
       
        # Apply the service manifest
        kubectl apply -f AKS-Deployment/appointment-service-dev.yml
       
        echo "Deployment manifests applied successfully!"
 
    - name: Wait for Deployment
      run: |
        # Wait for deployment rollout (adjust deployment name based on your manifest)
        kubectl rollout status deployment/appointment-service \
          --namespace=${{ env.NAMESPACE }} \
          --timeout=300s
 
    - name: Verify Deployment
      run: |
        echo "Deployment Status:"
        kubectl get deployment appointment-service -n ${{ env.NAMESPACE }}
        echo ""
        echo "Pod Status:"
        kubectl get pods -l app=appointment-service -n ${{ env.NAMESPACE }}
        echo ""
        echo "Service Status:"
        kubectl get service appointment-service -n ${{ env.NAMESPACE }}
 
    - name: Staging Deployment Complete
      run: |
        echo "✅ STAGING DEPLOYMENT COMPLETED SUCCESSFULLY!"
        echo "Service: Appointment Service"
        echo "Environment: Staging"
        echo "Image: ${{ env.REGISTRY_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}"
        echo "Namespace: ${{ env.NAMESPACE }}"
 
  deploy-production:
    name: Deploy to AKS Production
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production'
    environment: production
    needs: []  # Remove staging dependency if you want independent production deployments
   
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
 
    - name: Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      env:
        AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
 
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
 
    - name: Get AKS Credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
          --name ${{ env.AKS_CLUSTER_NAME }} \
          --overwrite-existing
 
    - name: Create Namespace if not exists
      run: |
        kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
 
    - name: Create ACR Secret
      run: |
        kubectl create secret docker-registry acr-secret \
          --namespace=${{ env.NAMESPACE }} \
          --docker-server=${{ env.REGISTRY_LOGIN_SERVER }} \
          --docker-username=appointmentservice \
          --docker-password=${{ secrets.APPOINTMENT_ACR_PASSWORD }} \
          --dry-run=client -o yaml | kubectl apply -f -
 
    - name: Determine Image Tag
      id: image-tag
      run: |
        if [ -n "${{ github.event.inputs.image_tag }}" ]; then
          echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
        else
          echo "tag=latest" >> $GITHUB_OUTPUT
        fi
 
    - name: Update Image in Production Deployment Manifest
      run: |
        IMAGE_TAG="${{ steps.image-tag.outputs.tag }}"
        IMAGE_FULL="${{ env.REGISTRY_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}"
       
        echo "Updating production deployment manifest with image: $IMAGE_FULL"
       
        # Copy dev manifest to prod and update for production settings
        cp AKS-Deployment/appointment-deployment-dev.yml AKS-Deployment/appointment-deployment-prod.yml
        cp AKS-Deployment/appointment-service-dev.yml AKS-Deployment/appointment-service-prod.yml
       
        # Update the image in the deployment manifest
        sed -i "s|image:.*|image: $IMAGE_FULL|g" AKS-Deployment/appointment-deployment-prod.yml
       
        # Update replicas for production (optional)
        sed -i "s|replicas:.*|replicas: 3|g" AKS-Deployment/appointment-deployment-prod.yml
       
        # Update environment variables for production (if needed)
        sed -i "s|NODE_ENV.*|NODE_ENV: production|g" AKS-Deployment/appointment-deployment-prod.yml
       
        echo "Updated production deployment manifest:"
        cat AKS-Deployment/appointment-deployment-prod.yml
 
    - name: Deploy to AKS Production
      run: |
        echo "Deploying to AKS Production using updated manifests..."
       
        # Apply the production deployment manifest
        kubectl apply -f AKS-Deployment/appointment-deployment-prod.yml
       
        # Apply the production service manifest
        kubectl apply -f AKS-Deployment/appointment-service-prod.yml
       
        echo "Production deployment manifests applied successfully!"
 
    - name: Wait for Deployment
      run: |
        kubectl rollout status deployment/appointment-service \
          --namespace=${{ env.NAMESPACE }} \
          --timeout=600s
 
    - name: Verify Deployment
      run: |
        echo "Deployment Status:"
        kubectl get deployment appointment-service -n ${{ env.NAMESPACE }}
        echo ""
        echo "Pod Status:"
        kubectl get pods -l app=appointment-service -n ${{ env.NAMESPACE }}
        echo ""
        echo "Service Status:"
        kubectl get service appointment-service -n ${{ env.NAMESPACE }}
 
    - name: Production Deployment Complete
      run: |
        echo "✅ PRODUCTION DEPLOYMENT COMPLETED SUCCESSFULLY!"
        echo "Service: Appointment Service"
        echo "Environment: Production"
        echo "Image: ${{ env.REGISTRY_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}"
        echo "Namespace: ${{ env.NAMESPACE }}"
 
